grammar cz.cuni.mff.d3s.jdeeco.edl.EDL with org.eclipse.xtext.common.Terminals

import "platform:/resource/cz.cuni.mff.d3s.jdeeco.edl.model/model/edl.ecore" 
import "http://www.eclipse.org/emf/2002/Ecore" as ecore

// ===== Document sections and building blocks =====
EdlDocument returns EdlDocument:
	{EdlDocument}	
		(ensembles+=EnsembleDefinition (ensembles+=EnsembleDefinition)*)?
	;

EnsembleDefinition returns EnsembleDefinition:
	'ensemble'
	    name=ID
	    'id' id=IdDefinition
		('child of' parentEnsemble=EString)?
		('parent of' childEnsembles+=ChildDefinition (childEnsembles+=ChildDefinition)*)?
		('alias' aliases+=AliasDefinition (aliases+=AliasDefinition)*)?
		'membership'
		  'roles' roles+=RoleDefinition (roles+=RoleDefinition)*		
		  ('constraints' constraints+=ConstraintDeclaration (constraints+=ConstraintDeclaration)*)?
		  ('fitness' fitness=OrdinalQuery)?
		'knowledge exchange' exchangeRules+=ExchangeRule (exchangeRules+=ExchangeRule)*
	 'end'	
;	


ChildDefinition returns ChildDefinition:
	name = ID '[' cardinalityMin=EInt '..' cardinalityMax=Cardinality ']' ':' type = QualifiedName	
;

RoleDefinition returns RoleDefinition:
	(exclusive?='exclusive')?
	name = ID '[' cardinalityMin=EInt '..' cardinalityMax=Cardinality ']' ':' type = QualifiedName	
;

// TODO: Solve *, probably via an IValueConverter
Cardinality returns ecore::EInt:
    EInt | ('*')
;

AliasDefinition returns AliasDefinition:
	aliasId = ID '=' aliasValue = Query	
;

IdDefinition returns IdDefinition:
	fieldName=EString ':' type = QualifiedName  (isAssigned?= ':=' value = Query)?
;

ExchangeRule returns ExchangeRule:
	field = QualifiedName ':=' query = Query
;

QualifiedName returns QualifiedName:
	{QualifiedName}
	(prefix+=ID '.' (prefix+=ID '.')*)?	
	name=ID
;


// ===== Core types (terminals) =====

EInt returns ecore::EInt:
	INT;

EBoolean returns ecore::EBoolean:
	'true' | 'false';

EString returns ecore::EString:
	STRING | ID;

EFloat returns ecore::EFloat:
	INT? '.' INT (('E'|'e') '-'? INT)?;


// ===== Atomic literals =====

FunctionCall returns FunctionCall:
	{FunctionCall}
	name = ID'(' parameters += Query (',' parameters += (Query))* ')'
;

KnowledgeVariable returns KnowledgeVariable:
	path=QualifiedName
;	

NumericLiteral returns NumericLiteral:
	value=EInt
;

BoolLiteral returns BoolLiteral:
	value = EBoolean
;

enum BinaryOperatorType returns BinaryOperatorType:
				Addition = 'Addition' | Subtraction = 'Subtraction' | Multiplication = 'Multiplication' | Division = 'Division';

StringLiteral returns StringLiteral:
	value=STRING
;

FloatLiteral returns FloatLiteral:
	value=EFloat
;

// ===== Constraints =====

ConstraintDeclaration returns Constraint:
	'constraint ' Constraint
;

Constraint returns Constraint:
	LogicalOperator
;


LogicalOperator returns Constraint:	
	LogicalTerm
	(({LogicalOperator.left = current}
		type=BoolOperatorType)
	right=LogicalTerm)*
;

LogicalTerm returns Constraint:
	RelationOperator
;

RelationOperator returns RelationOperator:		
	left=OrdinalQuery	
	('==' | '!=' | '<' | '>' | '<=' | '>=')
	right=OrdinalQuery
;

enum BoolOperatorType returns BoolOperatorType:
	And = 'and' | Or = 'or';

Negation returns Negation:
	'not' nested=Constraint;


// ===== Ordinal query (Fitness function, constraints) =====

OrdinalQuery returns OrdinalQuery:
	MultiplicativeOrdinalQuery
	(({AdditiveOperator.left=current}
	('+' | '-'))
	right=MultiplicativeOrdinalQuery)*
;

MultiplicativeOrdinalQuery returns OrdinalQuery:		
	AdditiveInverseOrdinalQuery
	(({MultiplicativeOperator.left=current}
	('*' | '/'))
	right=AdditiveInverseOrdinalQuery)*
;

AdditiveInverseOrdinalQuery returns OrdinalQuery:
	AdditiveInverseOrdinal | BaseOrdinalQuery
;

AdditiveInverseOrdinal returns AdditiveInverse:
	'-' nested=BaseOrdinalQuery
;

BaseOrdinalQuery returns OrdinalQuery:
	BoolLiteral | NumericLiteral | OrdinalFunctionCall | KnowledgeVariable | '(' OrdinalQuery ')'
;

OrdinalFunctionCall returns FunctionCall:
	{FunctionCall}
	name = ID '(' parameters += OrdinalQuery (',' parameters += (OrdinalQuery))* ')'
;

// ===== General query (knowledge exchange, aliasing) =====

Query returns Query:
	MultiplicativeQuery
	(({AdditiveOperator.left=current}
	('+' | '-'))
	right=MultiplicativeQuery)*
;

MultiplicativeQuery returns Query:		
	AdditiveInverseQuery
	(({MultiplicativeOperator.left=current}
	('*' | '/'))
	right=AdditiveInverseQuery)*
;

AdditiveInverseQuery returns Query:
	AdditiveInverse | BaseQuery
;

AdditiveInverse returns AdditiveInverse:
	'-' nested=BaseQuery
;

BaseQuery returns Query:
	StringLiteral | BoolLiteral | FloatLiteral | NumericLiteral | FunctionCall | KnowledgeVariable | '('Query')'
;