grammar cz.cuni.mff.d3s.jdeeco.edl.EDL with org.eclipse.xtext.common.Terminals

import "platform:/resource/cz.cuni.mff.d3s.jdeeco.edl.model/model/edl.ecore" 
import "http://www.eclipse.org/emf/2002/Ecore" as ecore

EdlDocument returns EdlDocument:
	{EdlDocument}	
		(ensembles+=EnsembleDefinition (ensembles+=EnsembleDefinition)*)?
	;

Constraint returns Constraint:
	FunctionCall | RelationOperator | LogicalOperator | Negation;

Query returns Query:
	MultiplicativeQuery
	(({AdditiveOperator.left=current}
	('+' | '-'))
	right=MultiplicativeQuery)*
;

//Query returns Query:
//	FunctionCall | KnowledgeVariable | NumericLiteral | BoolLiteral | StringLiteral | FloatLiteral | AdditiveOperator | MultiplicativeOperator | AdditiveInverse;

OrdinalQuery returns OrdinalQuery:
	BoolLiteral | NumericLiteral | FunctionCall | KnowledgeVariable; 

//OrdinalQuery returns OrdinalQuery:
//	FunctionCall | KnowledgeVariable | NumericLiteral | BoolLiteral | AdditiveOperator | MultiplicativeOperator | AdditiveInverse;


EnsembleDefinition returns EnsembleDefinition:
	'ensemble'
	    name=ID
	    'id' id=IdDefinition
		('child of' parentEnsemble=EString)?
		('parent of' childEnsembles+=ChildDefinition (childEnsembles+=ChildDefinition)*)?
		('alias' aliases+=AliasDefinition (aliases+=AliasDefinition)*)?
		'membership'
		  'roles' roles+=RoleDefinition (roles+=RoleDefinition)*		
		  ('constraints' constraints+=Constraint (constraints+=Constraint)*)?
		  ('fitness' fitness=Query)?
		'knowledge exchange' exchangeRules+=ExchangeRule (exchangeRules+=ExchangeRule)*
	 'end'	
;	

EString returns ecore::EString:
	STRING | ID;

ChildDefinition returns ChildDefinition:
	name = ID '[' cardinalityMin=EInt '..' cardinalityMax=Cardinality ']' ':' type = QualifiedName	
;

RoleDefinition returns RoleDefinition:
	(exclusive?='exclusive')?
	name = ID '[' cardinalityMin=EInt '..' cardinalityMax=Cardinality ']' ':' type = QualifiedName	
;

// TODO: Solve *, probably via an IValueConverter
Cardinality returns ecore::EInt:
    EInt | ('*')
;

AliasDefinition returns AliasDefinition:
	aliasId = ID '=' aliasValue = Query	
;

IdDefinition returns IdDefinition:
	fieldName=EString ':' type = QualifiedName  (isAssigned?= ':=' value = Query)?
;

ExchangeRule returns ExchangeRule:
	field = QualifiedName ':=' query = Query
;

EInt returns ecore::EInt:
	INT;

QualifiedName returns QualifiedName:
	{QualifiedName}
	(prefix+=ID '.' (prefix+=ID '.')*)?	
	name=ID
;

EBoolean returns ecore::EBoolean:
	'true' | 'false';

FunctionCall returns FunctionCall:
	{FunctionCall}
	name = ID'(' parameters += Query (',' parameters += (Query))* ')'
;

KnowledgeVariable returns KnowledgeVariable:
	path=QualifiedName
;	

NumericLiteral returns NumericLiteral:
	value=EInt
;

BoolLiteral returns BoolLiteral:
	value = EBoolean
;

enum BinaryOperatorType returns BinaryOperatorType:
				Addition = 'Addition' | Subtraction = 'Subtraction' | Multiplication = 'Multiplication' | Division = 'Division';

enum BoolOperatorType returns BoolOperatorType:
				And = 'and' | Or = 'or';

StringLiteral returns StringLiteral:
	value=STRING
;

FloatLiteral returns FloatLiteral:
	value=EFloat
;

EFloat returns ecore::EFloat:
	INT? '.' INT (('E'|'e') '-'? INT)?;

Negation returns Negation:
	'not' nested=Constraint;


MultiplicativeQuery returns Query:		
	AdditiveInverseQuery
	(({MultiplicativeOperator.left=current}
	('*' | '/'))
	right=AdditiveInverseQuery)*
;

AdditiveInverseQuery returns Query:
	AdditiveInverse | BaseQuery
;

AdditiveInverse returns AdditiveInverse:
	'-' nested=BaseQuery
;

BaseQuery returns Query:
	StringLiteral | BoolLiteral | FloatLiteral | NumericLiteral | FunctionCall | KnowledgeVariable | '('Query')'
;
	
	
//TODO:

RelationOperator returns RelationOperator:
	'RelationOperator'
	'{'
		'left' left=OrdinalQuery
		'right' right=OrdinalQuery
	'}';

LogicalOperator returns LogicalOperator:
	'LogicalOperator'
	'{'
		'type' type=BoolOperatorType
		'left' left=Constraint
		'right' right=Constraint
	'}';