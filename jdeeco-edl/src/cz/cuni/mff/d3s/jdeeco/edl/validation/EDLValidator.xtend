/*
 * generated by Xtext
 */
package cz.cuni.mff.d3s.jdeeco.edl.validation

import cz.cuni.mff.d3s.jdeeco.edl.model.edl.EnsembleDefinition
import org.eclipse.xtext.validation.Check
import cz.cuni.mff.d3s.jdeeco.edl.model.edl.*
import java.util.Map
import java.util.HashMap
import java.util.Set
import java.util.HashSet

/**
 * Custom validation rules. 
 *
 * see http://www.eclipse.org/Xtext/documentation.html#validation
 */
class EDLValidator extends AbstractEDLValidator {
	
	Map<String, TypeDefinition> dataTypes;
	Set<String> ensembleNames
	
	@Check
	def generateDocumentInfo(EdlDocument document) {
		dataTypes = new HashMap();
		ensembleNames = new HashSet();
		
		
		for (DataContractDefinition d : document.dataContracts) {
			if (!dataTypes.containsKey(d.name)) {
				dataTypes.put(d.name, d);
			} 
			else {
				error("Duplicate data type definition.", d, EdlPackage.Literals.TYPE_DEFINITION__NAME)
			}							
		}				
		
		for (TypeDefinition d : document.knowledgeTypes) {
			if (!dataTypes.containsKey(d.name)) {
				dataTypes.put(d.name, d);
			} 
			else {
				error("Duplicate data type definition.", d, EdlPackage.Literals.TYPE_DEFINITION__NAME)
			}							
		}
		
		for (EnsembleDefinition d : document.ensembles) {
			if (!ensembleNames.contains(d.name)) {
				ensembleNames.add(d.name);
			} 
			else {
				error("Duplicate ensemble definition.", d, EdlPackage.Literals.ENSEMBLE_DEFINITION__NAME)
			}							
		}
	}	
	
	@Check
	def validateType(TypeDefinition contract) {				
		for (FieldDeclaration d : contract.fields) {			
			switch (d.type.name) {
				case "int",
				case "string",
				case "float",
				case "bool":
					{}
				default:
					if(!dataTypes.containsKey(d.type.name)) {
						error("Field type must be either a primitive type or an existing knowledge type.", d, EdlPackage.Literals.FIELD_DECLARATION__TYPE)						
					}
					else {
						if (dataTypes.get(d.type.name) instanceof DataContractDefinition) {
							error("Field type must be a knowledge type, not a data contract.", d, EdlPackage.Literals.FIELD_DECLARATION__TYPE)
						}
					}
			}
		}
	}
	
	@Check
	def validateEnsembleDefinition(EnsembleDefinition ensemble) {
		if (ensemble.fitness != null) {
			val type = checkTypes(ensemble.fitness, ensemble)
			if (!type.equals("int"))
				error("Fitness function must be a numeric expression.", ensemble.fitness, EdlPackage.Literals.ENSEMBLE_DEFINITION__FITNESS)
		}
		
		for (Query c : ensemble.constraints) {
			val type = checkTypes(c, ensemble)
			// TODO: Improve model so the constraint errors can be reported per constraint
//			if (!type.equals("bool")) {
//				error("Constraint must be a logical expression. - " + type, ensemble, EdlPackage.Literals.ENSEMBLE_DEFINITION__CONSTRAINTS)
//			}
		}	
		
		for (AliasDefinition a : ensemble.aliases) {
			checkTypes(a.aliasValue, ensemble)
		}
		
		for (ExchangeRule rule : ensemble.exchangeRules) {
			var queryType = checkTypes(rule.query, ensemble)
			var fieldType = getKnowledgeType(rule.field, ensemble)
			
			if (!queryType.equals(fieldType)) {
				error("Invalid assignment - field and query types do not correspond.", rule, EdlPackage.Literals.EXCHANGE_RULE__FIELD)
			}
		}
		
		for (RoleDefinition roleDefinition : ensemble.roles) {
			if (dataTypes.containsKey(roleDefinition.type.name)) {
				if (!(dataTypes.get(roleDefinition.type.name) instanceof DataContractDefinition))
					error("The type is present, but is not a data contract.", roleDefinition, EdlPackage.Literals.CHILD_DEFINITION__TYPE)				
			}			
			else
				error("This data contract is not present in the package.", roleDefinition, EdlPackage.Literals.CHILD_DEFINITION__TYPE)
		}
		
		checkTypes(ensemble.id.value, ensemble)		
	}
	
	def String getKnowledgeType(QualifiedName name, TypeDefinition type, int position) {
		if (position >= name.prefix.length) {			
			var FieldDeclaration f = type.fields.findFirst[it.name.equals(name.name)]
			if (f != null) {
				return f.type.name.toLowerCase();
			}
			else {
				error("The specified data type does not contain a field of this name.", name, EdlPackage.Literals.QUALIFIED_NAME__NAME)
			}			
		}
		else {
			var FieldDeclaration f = type.fields.findFirst[it.name.equals(name.prefix.get(position))]
			if (f != null) {
				if(dataTypes.containsKey(f.type.name)) {
					var nestedType = dataTypes.get(f.type.name)										
					return getKnowledgeType(name, nestedType, position+1)					
				}
				else {
					error("A data type with this name was not found in the package.", name, EdlPackage.Literals.QUALIFIED_NAME__PREFIX)
				}
			}
			else {
				error("The specified data type does not contain a field of this name.", name, EdlPackage.Literals.QUALIFIED_NAME__PREFIX)
			}
		}
		
		"unknown"
	}
	
	def String getKnowledgeType(QualifiedName name, EnsembleDefinition ensemble) {		
		if (name.prefix.length == 0) {
			if(ensemble.id.fieldName.equals(name.name))
				return ensemble.id.type.name
			
			 var alias = ensemble.aliases.findFirst[it.aliasId.equals(name.name)]
			 if (alias != null)
			 	return checkTypes(alias.aliasValue, ensemble)	
			 	
			 var role = ensemble.roles.findFirst[it.name.equals(name.name)]
			 if (role != null) {									
					return role.type.name				
			}
			else {
				error("An element with this name was not found in the ensemble.", name, EdlPackage.Literals.QUALIFIED_NAME__NAME)
			}			 						
		}
		else {
			var role = ensemble.roles.findFirst[it.name.equals(name.prefix.findFirst[true])]
			if (role != null) {
				if(dataTypes.containsKey(role.type.name)) {
					var roleType = dataTypes.get(role.type.name)
					return getKnowledgeType(name, roleType, 1)
					
				}
				else {
					error("Could not resolve the name.", role.type, EdlPackage.Literals.QUALIFIED_NAME__PREFIX)
				}				
			}
			else {
				error("A role with this name was not found in the ensemble.", name, EdlPackage.Literals.QUALIFIED_NAME__PREFIX)
			}
		}
		
		"unknown"	
	}
	
	def String checkTypes(Query query, EnsembleDefinition ensemble) {		
		switch(query) {
		BoolLiteral:
			"bool"			
		NumericLiteral:
			"int"			
		StringLiteral:
			"string"
		FloatLiteral:
			"float"
		KnowledgeVariable: 
			{
				var QualifiedName name = query.path				 
				getKnowledgeType(name, ensemble)
			}
		LogicalOperator:
			{
				var String l = checkTypes(query.left, ensemble)
 				var String r = checkTypes(query.right, ensemble)
 				
 				if(!l.equals("bool"))
 					error("A parameter of a logical operator must be a logical value.", query, EdlPackage.Literals.LOGICAL_OPERATOR__LEFT)
 				
 				if(!r.equals("bool"))
 					error("A parameter of a logical operator must be a logical value.", query, EdlPackage.Literals.LOGICAL_OPERATOR__RIGHT)
 				
 				"bool"
 			} 			
		RelationOperator:
			{
				var String l = checkTypes(query.left, ensemble);
 				var String r = checkTypes(query.right, ensemble); 				
 				
 				if(!l.equals(r))
 				{
 					error("Both parameters of a relation must be of the same type.", query, EdlPackage.Literals.RELATION_OPERATOR__LEFT);
 				}
 				
 				if(query.type.equals(RelationOperatorType.EQUALITY) || query.type.equals(RelationOperatorType.NON_EQUALITY)) {
 					if (!(query.left instanceof EquitableQuery))
 						error("Parameters of this type of relation must be equitable.", query, EdlPackage.Literals.RELATION_OPERATOR__LEFT);
 				}
 				else {
 					if (!(query.left instanceof ComparableQuery))
 						error("Parameters of this type of relation must be comparable.", query, EdlPackage.Literals.RELATION_OPERATOR__LEFT);
 				}
 				
				"bool"
			}
		BinaryOperator:	
			{
				var String l = checkTypes(query.left, ensemble);
 				var String r = checkTypes(query.right, ensemble);
 				
 				if(!(l.equals("int") || l.equals("float")))
 					error("A parameter of a binary operator must be numeric.", query, EdlPackage.Literals.BINARY_OPERATOR__LEFT)
 				
 				
 				if(!(r.equals("int") || r.equals("float")))
 					error("A parameter of a binary operator must be numeric.", query, EdlPackage.Literals.BINARY_OPERATOR__RIGHT)
 				
 				
 				if(!l.equals(r))
 				{
 					error("Both parameters of a binary operator must be of the same numeric type.", query, EdlPackage.Literals.BINARY_OPERATOR__LEFT);
 				}
 				
				l		
			}
		AdditiveInverse:
			{
				var String inner = checkTypes(query.nested, ensemble);
				
				if(!inner.equals("int") && !inner.equals("float"))
					error("The nested expression of a additive inverse must be a numeric expression.", query, EdlPackage.Literals.ADDITIVE_INVERSE__NESTED)								
				inner
			}
		Negation:
			{
				var String inner = checkTypes(query.nested, ensemble);
				
				if(!inner.equals("bool"))
					error("The nested expression of a negation must be logical expression.", query, EdlPackage.Literals.NEGATION__NESTED)								
				"bool"
			}
		FunctionCall:
		// TODO: Check function calls, needs info on available functions and their typing.
			
			"goo"			
		default:
			"unknown"
			
		}
	}
}
