/*
 * generated by Xtext
 */
package cz.cuni.mff.d3s.jdeeco.edl.validation

import cz.cuni.mff.d3s.jdeeco.edl.model.edl.EnsembleDefinition
import org.eclipse.xtext.validation.Check
import cz.cuni.mff.d3s.jdeeco.edl.model.edl.*
import java.util.Set
import java.util.HashSet
import com.google.inject.Inject
import cz.cuni.mff.d3s.jdeeco.edl.utils.EDLUtils
import org.eclipse.emf.ecore.EStructuralFeature
import org.eclipse.emf.ecore.EObject
import cz.cuni.mff.d3s.jdeeco.edl.PrimitiveTypes
import cz.cuni.mff.d3s.jdeeco.edl.typing.ITypeInformationProvider
import cz.cuni.mff.d3s.jdeeco.edl.typing.DefaultTypeInformationProvider
import cz.cuni.mff.d3s.jdeeco.edl.functions.IFunctionRegistry
import cz.cuni.mff.d3s.jdeeco.edl.validation.IErrorReportingService
import cz.cuni.mff.d3s.jdeeco.edl.ContextSymbols

/**
 * Custom validation rules. 
 *
 * see http://www.eclipse.org/Xtext/documentation.html#validation
 */
class EDLValidator extends AbstractEDLValidator implements IErrorReportingService {
	
	Set<String> ensembleNames
	ITypeInformationProvider typing;
	
	@Inject
	IFunctionRegistry registry;
	
	@Check
	def generateDocumentInfo(EdlDocument document) {
			
		
		ensembleNames = new HashSet();	
		
		for (EnsembleDefinition d : document.ensembles) {
			if (!ensembleNames.contains(d.name)) {
				ensembleNames.add(d.name);
			} 
			else {
				reportError("Duplicate ensemble definition.", d, EdlPackage.Literals.ENSEMBLE_DEFINITION__NAME)
			}							
		}
		
		typing = new DefaultTypeInformationProvider(this, document, registry);
	}	
	
	@Check
	def validateType(TypeDefinition contract) {				
		for (FieldDeclaration d : contract.fields) {			
			switch (d.type.name) {
				case PrimitiveTypes.INT,
				case PrimitiveTypes.STRING,
				case PrimitiveTypes.FLOAT,
				case PrimitiveTypes.BOOL:
					{}
				default:
					if(!typing.isKnownType(d.type)) {
						reportError("Field type must be either a primitive type or an existing knowledge type.", d, EdlPackage.Literals.FIELD_DECLARATION__TYPE)						
					}
					else {
						if (typing.getDataType(d.type) instanceof DataContractDefinition) {
							reportError("Field type must be a knowledge type, not a data contract.", d, EdlPackage.Literals.FIELD_DECLARATION__TYPE)
						}
					}
			}
		}
	}
	
	@Check
	def validateEnsembleDefinition(EnsembleDefinition ensemble) {
		if (ensemble.fitness != null) {
			val type = typing.getType(ensemble.fitness, ensemble)
			if (!type.equals(PrimitiveTypes.INT))
				reportError("Fitness function must be a numeric expression.", ensemble, EdlPackage.Literals.ENSEMBLE_DEFINITION__FITNESS)
		}
		
		if (!this.typing.isKnownType(ensemble.id.type) && !ensemble.id.type.toString().equals(PrimitiveTypes.INT))
				reportError("Could not resolve the type name: " + ensemble.id.type, ensemble.id.type, EdlPackage.Literals.QUALIFIED_NAME__PREFIX)
		
		if (ensemble.id.isIsAssigned) {
			var queryType = typing.getType(ensemble.id.value, ensemble)
			var fieldType = ensemble.id.type;
			
			if (!EDLUtils.convertible(queryType, fieldType.name)) {
				reportError("Invalid assignment - Id and query types do not correspond. Id type: " + fieldType + " Query type: " + queryType, ensemble.id, EdlPackage.Literals.ID_DEFINITION__VALUE)
			}
		}		
		
		for (Query c : ensemble.constraints) {
			val type = typing.getType(c, ensemble)
			
			if (!type.equals(PrimitiveTypes.BOOL)) {
				reportError("Constraint must be a logical expression. - " + type, ensemble, EdlPackage.Literals.ENSEMBLE_DEFINITION__CONSTRAINTS, ensemble.constraints.indexOf(c))
			}
		}	
		
		for (AliasDefinition a : ensemble.aliases) {
			typing.getType(a.aliasValue, ensemble)
		}
		
		for (ExchangeRule rule : ensemble.exchangeRules) {
			var queryType = typing.getType(rule.query, ensemble)
			var fieldType = typing.getKnowledgeType(rule.field, ensemble)
			
			if (!EDLUtils.convertible(queryType, fieldType)) {
				reportError("Invalid assignment - field and query types do not correspond. Field type: " + fieldType + " Query type: " + queryType, rule, EdlPackage.Literals.EXCHANGE_RULE__FIELD)
			}
			
			if (queryType.equals(fieldType) && !EDLUtils.stripSet(fieldType).startsWith(ContextSymbols.SET_SYMBOL) && ensemble.roles.exists[it.cardinalityMax != 1 && rule.field.toParts().get(0).equals(it.name)]) {
				reportError("Invalid assignment - it is not allowed to change the members of a role in knowledge exchange rules." , rule, EdlPackage.Literals.EXCHANGE_RULE__FIELD)
			}
		}
		
		for (RoleDefinition roleDefinition : ensemble.roles) {
			if (typing.isKnownType(roleDefinition.type)) {
				if (!(typing.getDataType(roleDefinition.type) instanceof DataContractDefinition))
					reportError("The type is present, but is not a data contract: " + roleDefinition.type, roleDefinition, EdlPackage.Literals.CHILD_DEFINITION__TYPE)
					
				if (roleDefinition.whereFilter != null) {
					if (typing.getType(roleDefinition.whereFilter, ensemble, roleDefinition) != PrimitiveTypes.BOOL) {						
						reportError("A query used in the where filter must return logical value.", roleDefinition, EdlPackage.Literals.ROLE_DEFINITION__WHERE_FILTER)					
					}
					
					
				}				
			}			
			else
				reportError("This data contract is not present in the package: " + roleDefinition.type, roleDefinition, EdlPackage.Literals.CHILD_DEFINITION__TYPE)				
		}
		
		typing.getType(ensemble.id.value, ensemble)		
	}
	
	override reportError(String message, EObject source, EStructuralFeature feature) {
		error(message, source, feature)
	}
	
	override reportError(String message, EObject source, EStructuralFeature feature, int index) {
		error(message, source, feature, index)
	}
}
