/*
 * generated by Xtext
 */
package cz.cuni.mff.d3s.jdeeco.edl.validation

import cz.cuni.mff.d3s.jdeeco.edl.model.edl.EnsembleDefinition
import org.eclipse.xtext.validation.Check
import cz.cuni.mff.d3s.jdeeco.edl.model.edl.*

/**
 * Custom validation rules. 
 *
 * see http://www.eclipse.org/Xtext/documentation.html#validation
 */
class EDLValidator extends AbstractEDLValidator {
	
	@Check
	def ensembleTypeInformation(EnsembleDefinition ensemble) {
				
		val type = checkTypes(ensemble.fitness)
		if (!type.equals("int"))
			error("Fitness function must be a numeric expression.", ensemble.fitness, EdlPackage.Literals.ENSEMBLE_DEFINITION__FITNESS)
		
		for (Query c : ensemble.constraints) {
			checkTypes(c)
		}	
		
		for (AliasDefinition a : ensemble.aliases) {
			checkTypes(a.aliasValue)
		}
		
		for (ExchangeRule rule : ensemble.exchangeRules) {
			checkTypes(rule.query)
		}
		
		checkTypes(ensemble.id.value)		
	}
	
	def String checkTypes(Query query) {		
		switch(query) {
		BoolLiteral:
			"bool"			
		NumericLiteral:
			"int"			
		StringLiteral:
			"string"
		FloatLiteral:
			"float"
		KnowledgeVariable: 
			// TODO: Return correct type of knowledge, needs info on roles and structured types 
			"knowledge"
		LogicalOperator:
			{
				var String l = checkTypes(query.left)
 				var String r = checkTypes(query.right)
 				
 				if(!l.equals("bool"))
 					error("A parameter of a logical operator must be a logical value.", query, EdlPackage.Literals.LOGICAL_OPERATOR__LEFT)
 				
 				if(!r.equals("bool"))
 					error("A parameter of a logical operator must be a logical value.", query, EdlPackage.Literals.LOGICAL_OPERATOR__RIGHT)
 				
 				"bool"
 			} 			
		RelationOperator:
			{
				var String l = checkTypes(query.left);
 				var String r = checkTypes(query.right); 				
 				
 				if(!l.equals(r))
 				{
 					error("Both parameters of a relation must be of the same type.", query, EdlPackage.Literals.RELATION_OPERATOR__LEFT);
 				}
 				
				"bool"
			}
		BinaryOperator:	
			{
				var String l = checkTypes(query.left);
 				var String r = checkTypes(query.right);
 				
 				if(!(l.equals("int") || l.equals("float")))
 					error("A parameter of a binary operator must be numeric.", query, EdlPackage.Literals.BINARY_OPERATOR__LEFT)
 				
 				
 				if(!(r.equals("int") || r.equals("float")))
 					error("A parameter of a binary operator must be numeric.", query, EdlPackage.Literals.BINARY_OPERATOR__RIGHT)
 				
 				
 				if(!l.equals(r))
 				{
 					error("Both parameters of a binary operator must be of the same numeric type.", query, EdlPackage.Literals.BINARY_OPERATOR__LEFT);
 				}
 				
				l		
			}
		AdditiveInverse:
			{
				var String inner = checkTypes(query.nested);
				
				if(!inner.equals("int") && !inner.equals("float"))
					error("The nested expression of a additive inverse must be a numeric expression.", query, EdlPackage.Literals.ADDITIVE_INVERSE__NESTED)								
				inner
			}
		Negation:
			{
				var String inner = checkTypes(query.nested);
				
				if(!inner.equals("bool"))
					error("The nested expression of a negation must be logical expression.", query, EdlPackage.Literals.NEGATION__NESTED)								
				"bool"
			}
		FunctionCall:
		// TODO: Check function calls, needs info on available functions and their typing.
			
			"goo"			
		default:
			"unknown"
			
		}
	}
}
